---
title: "[Swift] 상속-2"
share: false
toc: true
toc_sticky: true
categories:
- swift
---

## 클래스 이니셜라이저  
### 지정 이니셜라이저, 편의 이니셜라이저  
**지정 이니셜라이저**는 클래스의 주요 이니셜라이저이다. 자식 클래스에서 필요하면 부모 클래스의 이니셜라이저를 호출할 수도 있다.  
**편의 이니셜라이저**는 지정 이니셜라이저를 자기 자신 내부에서 호출을 한다.  
편의 이니셜라이저는 필수 요수는 아니다.  
```swift
init( 매개변수들 ){
    // 초기화
} // 지정 이니셜라이저

convenience init (매개 변수들){
    // 초기화
} // 편의 이니셜라이저

```
### 클래스의 초기화 위임  
지정 이니셜라이저와 편의 이니셜라이저에는 3가지 규칙이 있다.  
**1. 자식 클래스의 지정 이니셜라이저는 부모 클래스의 지정 이니셜라이저를 반드시 호출해야 한다.**  
**2. 편의 이니셜라이저는 다른 이니셜라이저를 반드시 호출해야 한다.**  
**3. 편의 이니셜라이저는 궁극적으로 지정 이니셜라이저를 호출해야 한다.**  

### 2단계 초기화  
클래스를 초기화하는데에는 2단계를 거치게 된다.  
1단계는 클래스에 정의한 각각의 저장 프로퍼티에 값이 할당이 되고,  
2단계는 이 저장 프로퍼티들을 사용자 정의할 기회를 얻게 된다.  
2단계 초기화를 통해 초기화 하기 전에 프로퍼티 값에 접근 하는 것을 막아 안전하게 된다. 그리고 다른 이니셜라이저가 실수로 값을 변경하는 것도 방지할 수 있다.  
2단계 초기화를 하기 위해선 아래와 같이 4가지 확인이 필요하다.  

> 
>	자식 클래스의 지정 이니셜라이저가 부모 클래스의 이니셜라이저를 호출하기 전에 자신의 프로퍼티를 모두 초기화 했는지 확인  
>	
>	자식 클래스의 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 반드시 부모 클래스의 이니셜라이저를 호출해야 한다.  
>	
>	편의 이니셜라이저는 자신의 클래스에 정의한 프로퍼티를 포함하여 그 어떤 프로퍼티라도 값을 할당하기 전에 다른 이니셜라이저를 호출해야 한다.  
>	
>	초기화 1단계가 끝나기 전에는 이니셜라이저는 인스턴트 메서드를 호출하고 읽을 수도 없다. self 프로퍼티를 인스턴스를 나타내는 값으로 활용할 수도 없다.  
> 

- 1단계  
	- 클래스가 지정 / 편의 이니셜라이저를 호출한다.  
	- 그 클래스의 새로운 인스턴스를 위한 메모리 할당.  
	- 지정 이니셜라이저가 클래스에 정의된 모든 저장 프로퍼티에 값이 있는지 확인. => 현재 클래스 부분가지 저장 프로퍼티를 위한 메모리는 초기화 됨.  
	- 지정 이니셜라이저는 보무 클래스의 이니셜라이저가 같은 동작을 수행할 수 있도록 초기화 양도.  
	- 부모 클래스는 상속 체인을 따라 최상위 클래스로 갈 때 까지 이 작업 반복  
- 2단계  
	- 최상위 클래스에서 최하위 클래스까지 상속 체인을 따라 내려오면서 지정 이니셜라이저들이 인스턴스를 정의함. self를 통해 수정할 수 있고 인스턴스 메서드를 호출할 수도 있음.  
	- 각각의 편의 이니셜라이저를 통해 self를 통해 사용자 정의 작업 진행.  

```swift
class Person{
    var name : String
    var age : IntegerLiteralType
    init(name : String, age : Int){
        self.name = name
        self.age = age
    }
}
class Customer : Person {
    var date : Int
    init(name : String, age : Int, date : Int){
        self.date = date
        super.init(name:name, age:age)
    }
    convenience init(name: String){
        self.init(name : name, age : 26, date : 900)
    }
}
```
- 위와 같은 코드에서 Customer의 지정 이니셜라이저는 부모 클래스의 지정 이니셜라이저를 호출 하기 전에 `date` 를 할당해 줬으므로 4가지 확인 중 첫번째에 만족한다.  
- `super.init`을 통해 부모 클래스의 지정 이니셜라이저를 호출 했으므로 2번 조건을 만족한다.  
- 편의 이니셜라이저는 따로 값을 할당할 프로퍼티가 없고 다른 이니셜라이저를 호출했으므로 3번에 만족한다.  
- 이니셜라이저에서 아무도 인스턴스 메서드를 호출하거나 값을 읽어오지 않았으므로 4번도 만족한다.  


### 이니셜라이저 상속 / 재정의  
기본적으로는 부모 클래스의 이니셜라이저를 상속받지 않는다.  
상속이 되어도 안전하다면 자동 상속을 통해서 수행이 된다.  
보통은 `override` 키워드를 이용해 자식 클래스에서 부모 클래스의 이니셜라이저를 재정의 한다.  
편의 이니셜라이저는 자식 클래스에서 부모 클래스 편의 이니셜라이저를 호출하지 못하므로 재정의 할 필요가 없다.  
```swift
class Person{
    var name : String
    var age : IntegerLiteralType
    init(name : String, age : Int){
        self.name = name
        self.age = age
    }
    convenience init(name : String){
        self.init(name : name, age : 25)
    }
}
class Customer : Person {
    var date : Int
    override init(name : String, age : Int){
        self.date = 900
        super.init(name:name, age:age)
    } // 지정 이니셜라이저는 재정의가 필요하다.
    convenience init(name: String){
        self.init(name : name, age : 26)
    }  // 편의 이니셜라이저는 재정의 안해도 됨
}

```
### 이니셜라이저 자동 상속   
이니셜라이저가 자동으로 상속이 이루어지는 경우는 다음과 같다.  
- 자식 클래스에서 별도의 지정 이니셜라이저를 구현하지 않을 경우  
- 위의 경우로 자동으로 상속을 받은 경우 혹은 부모 클래스의 지정 이니셜라이저를 모두 재정의하여 부모 클래스와 동일한 지정 이니셜라이저를 모두 사용할 수 있는 상황이면 편의 이니셜라이저까지 모두 상속이 된다.  


### 요구 이니셜라이저  
`required` 키워드를 이용해 이니셜라이저 앞에 명시해 주면 이 클래스를 상속 받은 클래스들은 이 이니셜라이저를 반드시 재정의를 해야한다.  
이 때 `override`가 아닌 `required`로 재정의를 해준다.  
```swift
class Person{
    var name : String
    
    required init(){
        self.name = "John Doe"
    } // 요구 이니셜라이저 정의
}
class Customer : Person {
    var date : Int = 0
    
    init(date : Int){
        self.date = date
        super.init()
    } // 자신의 지정 이니셜라이저
    
    required init(){
        self.date = 20
        super.init()
    } // 요구 이니셜라이저 재정의
 
}

```
